[toc]

　　匿名函数是指不需要定义函数名的一种函数实现方式，它并不是一个新概念，最早可以回溯到1958年的 Lisp 语言。但是由于各种原因，C 和 C++ 一直都没有对匿名函数给以支持，其他的各种语言，比如 JavaScript、C# 和 Objective-C 等语言都提供了匿名函数特性，当然也包含 Go 语言。

# 匿名函数

　　在 Go 里面，函数可以像普通变量一样被传递或使用，属于和变量一样的`一级公民`，这与 C 语言的回调函数比较类似。不同的是，Go 语言支持随时在代码里定义匿名函数。

　　匿名函数由一个不带函数名的函数声明和函数体组成，如下所示：

```
func(a, b int, z float64) bool {
	return a*b <int(z)
}
```

　　匿名函数可以直接赋值给一个变量或者直接执行:

```
f := func(x, y int) int {
	return x + y
}

func(ch chan int) {
	ch <- ACK
} (reply_chan) // 花括号后直接跟参数列表表示函数调用
```

# 闭包

　　Go 的匿名函数是一个闭包，下面我们先来了解一下闭包的概念、价值和应用场景。

* 基本概念

　　闭包是可以包含自由（未绑定到特定对象）变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块（由于自由变量包含在代码块中，所以这些自由变量以及它们引用的对象没有被释放）为自由变量提供绑定的计算环境（作用域）。

* 闭包的价值

　　闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第`一级对象`，就是说这些**函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。**

* Go 语言中的闭包

　　Go 语言中的闭包同样也会引用到函数外的变量。**闭包的实现确保只要闭包还被使用，那么被闭包引用的变量会一直存在**，如下面代码所示。

```
package main

import (
	"fmt"
)

func main() {
	var j int = 5
	a := func()(func()) {
		var i int = 10
		return func() {
			fmt.Printf("i, j: %d, %d\n", i, j)
		}
	}()
	
	a()
	j *= 2
	a()
}
```

　　上述例子的执行结果是：

```
i, j: 10, 5
i, j: 10, 10
```

　　在上面的例子中，变量 a 指向的闭包函数引用了局部变量 i 和 j，i 的值被隔离，在闭包外不能被修改，改变 j 的值以后，再次调用 a，发现结果是修改过的值。

　　在变量 a 指向的闭包函数中，只有内部的匿名函数才能访问变量 i，而无法通过其他途径访问到，因此保证了 i 的安全性。

